<!DOCTYPE html>
<html>
<head>
    <title>Infinite Minesweeper - Fixed</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root { --bg: #1a1a1a; --panel: #2d2d2d; --text: #eee; --accent: #ffffff; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: sans-serif; touch-action: none; color: var(--text); }
        canvas { display: block; image-rendering: crisp-edges; image-rendering: pixelated; }
        #hud { position: absolute; top: 10px; left: 10px; background: var(--panel); padding: 10px; border: 3px outset #444; pointer-events: none; }
        #coords { position: absolute; bottom: 10px; right: 10px; background: rgba(0,0,0,0.5); padding: 5px; font-family: monospace; }
    </style>
</head>
<body>
    <div id="hud">
        Revealed: <span id="count">0</span><br>
        Mines: <span id="mines">0</span>
    </div>
    <div id="coords">0, 0</div>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Performance boost: no transparency
let TILE_SIZE = 40, zoom = 1.0, targetZoom = 1.0;
let camera = { x: 0, y: 0 };
let worldSeed = Math.floor(Math.random() * 999999);
let revealed = new Set(), flagged = new Set(), detonated = new Set();
let lastMouse = {x:0, y:0}, isDragging = false, dragMoved = false;

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

const getSeed = (x, y) => {
    let n = Math.sin((x + worldSeed) * 12.9898 + (y + worldSeed) * 78.233) * 43758.5453;
    return n - Math.floor(n);
};
const hasMine = (x, y) => getSeed(x, y) < 0.15;
const getCount = (x, y) => {
    let c = 0;
    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
        if(i===0 && j===0) continue;
        if(hasMine(x+i, y+j)) c++;
    }
    return c;
};

function render() {
    // 1. Clear with a solid color to prevent trailing
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    zoom += (targetZoom - zoom) * 0.1;
    
    ctx.save();
    // 2. Center the camera and apply zoom at the context level
    ctx.translate(canvas.width / 2, canvas.height / 2);
    ctx.scale(zoom, zoom);
    ctx.translate(-camera.x, -camera.y);

    const viewW = canvas.width / zoom;
    const viewH = canvas.height / zoom;
    const startX = Math.floor((camera.x - viewW/2) / TILE_SIZE);
    const startY = Math.floor((camera.y - viewH/2) / TILE_SIZE);
    const endX = startX + Math.ceil(viewW / TILE_SIZE) + 1;
    const endY = startY + Math.ceil(viewH / TILE_SIZE) + 1;

    for (let x = startX; x <= endX; x++) {
        for (let y = startY; y <= endY; y++) {
            const k = `${x},${y}`;
            const px = x * TILE_SIZE;
            const py = y * TILE_SIZE;

            // DRAWING LOGIC
            if (!revealed.has(k)) {
                ctx.fillStyle = flagged.has(k) ? "#ff4444" : "#333";
                // Using a 1px overlap (TILE_SIZE + 1) to eliminate sub-pixel gaps (stripes)
                ctx.fillRect(px, py, TILE_SIZE + 0.5, TILE_SIZE + 0.5);
                
                // Borders (only if zoomed in enough to see them)
                if (zoom > 0.5) {
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 1/zoom;
                    ctx.strokeRect(px, py, TILE_SIZE, TILE_SIZE);
                }
            } else {
                ctx.fillStyle = detonated.has(k) ? "#600" : "#111";
                ctx.fillRect(px, py, TILE_SIZE + 0.5, TILE_SIZE + 0.5);
                
                if (zoom > 0.3) {
                    let c = getCount(x, y);
                    if (c > 0 && !hasMine(x, y)) {
                        ctx.fillStyle = ["", "#3498db", "#2ecc71", "#e74c3c", "#9b59b6", "#f1c40f", "#1abc9c", "#34495e", "#7f8c8d"][c];
                        ctx.font = `bold ${TILE_SIZE/2}px Arial`;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(c, px + TILE_SIZE/2, py + TILE_SIZE/2);
                    } else if (hasMine(x, y)) {
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.arc(px + TILE_SIZE/2, py + TILE_SIZE/2, TILE_SIZE/4, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
        }
    }
    ctx.restore();

    document.getElementById('count').innerText = revealed.size;
    document.getElementById('mines').innerText = detonated.size;
    document.getElementById('coords').innerText = `${Math.floor(camera.x/TILE_SIZE)}, ${Math.floor(camera.y/TILE_SIZE)}`;
    requestAnimationFrame(render);
}

// Controls
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    targetZoom = Math.max(0.1, Math.min(targetZoom * (e.deltaY > 0 ? 0.8 : 1.2), 10));
}, {passive: false});

canvas.onmousedown = e => {
    isDragging = true;
    lastMouse = {x: e.clientX, y: e.clientY};
    dragMoved = false;
};

window.onmousemove = e => {
    if (!isDragging) return;
    let dx = e.clientX - lastMouse.x;
    let dy = e.clientY - lastMouse.y;
    if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
        camera.x -= dx / zoom;
        camera.y -= dy / zoom;
        dragMoved = true;
    }
    lastMouse = {x: e.clientX, y: e.clientY};
};

window.onmouseup = e => {
    if (!isDragging) return;
    if (!dragMoved) {
        const rect = canvas.getBoundingClientRect();
        const mx = (e.clientX - rect.left - canvas.width/2) / zoom + camera.x;
        const my = (e.clientY - rect.top - canvas.height/2) / zoom + camera.y;
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        
        if (e.button === 0) { // Left click
            const k = `${tx},${ty}`;
            if (!flagged.has(k)) {
                revealed.add(k);
                if (hasMine(tx, ty)) detonated.add(k);
            }
        } else if (e.button === 2) { // Right click
            const k = `${tx},${ty}`;
            if (!revealed.has(k)) {
                flagged.has(k) ? flagged.delete(k) : flagged.add(k);
            }
        }
    }
    isDragging = false;
};

canvas.oncontextmenu = e => e.preventDefault();
render();
</script>
</body>
</html>
