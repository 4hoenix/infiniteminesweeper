<!DOCTYPE html>
<html>
<head>
    <title>Infinite Minesweeper</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸš©</text></svg>">
    <style>
        :root {
            --bg: #1a1a1a; --panel: #2d2d2d; --text: #eee; --inset: #000; --outset: #444;
            --accent: #ffffff;
            --tile-shadow: #000000; --tile-highlight: #444444;
        }
        .light-mode {
            --bg: #bdbdbd; --panel: #bdbdbd; --text: #000; --inset: #7b7b7b; --outset: #fff; 
            --tile-shadow: #7b7b7b; --tile-highlight: #ffffff;
        }
        body { 
            margin: 0; overflow: hidden; background: var(--bg); 
            font-family: 'Segoe UI', sans-serif; touch-action: none; 
            color: var(--accent); user-select: none; cursor: default;
        }
        canvas { display: block; image-rendering: pixelated; }

        #hud {
            position: absolute; top: 10px; left: 10px; z-index: 100;
            background: var(--panel); border: 3px outset var(--outset);
            width: 110px; padding: 5px; display: flex; flex-direction: column; gap: 5px;
        }
        #minimap-frame { width: 100px; height: 100px; border: 2px inset var(--outset); background: #000; }
        #stats-bar {
            width: 100%; background: #000; color: var(--accent);
            font-family: 'Courier New', monospace; font-size: 14px;
            padding: 4px 5px; border: 2px inset var(--inset); box-sizing: border-box;
            display: flex; justify-content: space-between;
        }

        #top-right { position: absolute; top: 10px; right: 10px; display: flex; gap: 8px; z-index: 100; }
        .sq-btn {
            width: 50px; height: 50px; background: var(--panel); border: 3px outset var(--outset);
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            font-weight: bold; color: var(--accent); font-size: 18px;
        }
        .sq-btn:active { border-style: inset; }

        #side-menu {
            display: none; position: fixed; top: 70px; right: 10px; width: 240px;
            background: var(--panel); border: 3px outset var(--outset); padding: 15px; z-index: 101;
            color: var(--accent); box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #side-menu.active { display: block; }
        .menu-row { display: flex; justify-content: space-between; align-items: center; font-size: 14px; margin: 12px 0; font-family: monospace; }
        
        .modal {
            display: none; position: fixed; top: 70px; right: 10px; left: 10px;
            background: var(--panel); border: 3px outset var(--outset); padding: 20px; z-index: 200; 
            text-align: center; color: var(--accent);
        }
        .modal.active { display: block; }

        #cam-coords { 
            position: absolute; bottom: 10px; right: 10px; 
            font-family: monospace; font-size: 14px; 
            background: var(--panel); border: 2px inset var(--outset);
            padding: 5px 10px; pointer-events: none; color: var(--accent);
        }

        select, input[type="text"] {
            padding: 5px; border: 2px inset var(--outset); 
            background: #000; color: var(--accent);
            font-family: monospace; outline: none;
        }
    </style>
</head>
<body>

<div id="hud">
    <div id="minimap-frame"><canvas id="minimap" width="100" height="100"></canvas></div>
    <div id="stats-bar">
        <span>D:<b id="det-count">0</b></span>
        <span>F:<b id="flg-count">0</b></span>
    </div>
</div>

<div id="top-right">
    <div class="sq-btn" onclick="toggleWarp()">GO</div>
    <div class="sq-btn" onclick="toggleMenu()">â˜°</div>
</div>

<div id="side-menu">
    <div style="font-size: 12px; font-weight: bold; border-bottom: 1px solid var(--inset); margin-bottom: 8px;">DEDICATION STATS</div>
    <div class="menu-row"><span>Revealed:</span><span id="menu-revealed">0</span></div>
    <div class="menu-row"><span>Playtime:</span><span id="menu-time">0s</span></div>
    
    <div style="font-size: 12px; font-weight: bold; border-bottom: 1px solid var(--inset); margin: 20px 0 8px 0;">WORLD SETTINGS</div>
    <div class="menu-row">
        <span>Difficulty:</span>
        <select id="diffSelect" onchange="changeDifficulty(this.value)">
            <option value="0.12">Beginner (12%)</option>
            <option value="0.15">Intermediate (15%)</option>
            <option value="0.21">Expert (21%)</option>
        </select>
    </div>
    
    <button class="sq-btn" style="width:100%; height:40px; margin-bottom: 15px; font-size: 12px;" onclick="toggleTheme()">SWAP THEME</button>
    <div class="menu-row">
        <span>Accent:</span>
        <input type="color" id="colorPicker" value="#ffffff" onchange="updateAccent(this.value)" style="border:none; background:none; height:30px; width:50px;">
    </div>
    <button class="sq-btn" style="width:100%; height:45px; margin-top: 20px; font-size: 12px; color: #ff5555;" onclick="confirmReset()">REGENERATE WORLD</button>
</div>

<div id="warpModal" class="modal">
    <strong>WARP TO COORDINATES</strong><br><br>
    <input type="text" id="warpIn" placeholder="e.g. 500, -500"><br><br>
    <button class="sq-btn" style="width:100%; height:50px;" onclick="doWarp()">JUMP</button>
</div>

<div id="cam-coords">0, 0</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mCanvas = document.getElementById('minimap');
const mCtx = mCanvas.getContext('2d');

let TILE_SIZE = 40, zoom = 1.0, targetZoom = 1.0;
let camera = { x: 0, y: 0 }; 
let worldSeed = Math.floor(Math.random() * 999999);
let mineDensity = 0.15;

let startTime = Date.now();
let totalPlayedTime = 0;
let isTabActive = true;

let revealed = new Set(), flagged = new Set(), detonated = new Set();
let lastMouse = {x:0, y:0}, isDragging = false, dragMoved = false;
let keys = {};
let chordTarget = null;
let touchTimer = null;

document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
        isTabActive = false;
        totalPlayedTime += (Date.now() - startTime);
        saveGame();
    } else {
        isTabActive = true;
        startTime = Date.now();
    }
});

function formatTime(ms) {
    let s = Math.floor(ms / 1000);
    let d = Math.floor(s / 86400); s %= 86400;
    let h = Math.floor(s / 3600); s %= 3600;
    let m = Math.floor(s / 60); s %= 60;
    let res = "";
    if (d > 0) res += d + "d ";
    if (h > 0 || d > 0) res += h.toString().padStart(2, '0') + "h ";
    if (m > 0 || h > 0 || d > 0) res += m.toString().padStart(2, '0') + "m ";
    res += s.toString().padStart(2, '0') + "s";
    return res;
}

function saveGame() {
    const saveData = {
        worldSeed, camera, mineDensity,
        revealed: Array.from(revealed),
        flagged: Array.from(flagged),
        detonated: Array.from(detonated),
        totalPlayedTime: totalPlayedTime + (isTabActive ? (Date.now() - startTime) : 0),
        accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim()
    };
    localStorage.setItem('inf_minesweeper_save', JSON.stringify(saveData));
}

function loadGame() {
    const raw = localStorage.getItem('inf_minesweeper_save');
    if (!raw) return;
    const data = JSON.parse(raw);
    worldSeed = data.worldSeed;
    camera = data.camera;
    mineDensity = data.mineDensity || 0.15;
    document.getElementById('diffSelect').value = mineDensity;
    revealed = new Set(data.revealed);
    flagged = new Set(data.flagged);
    detonated = new Set(data.detonated);
    totalPlayedTime = data.totalPlayedTime || 0;
    if(data.accent) {
        updateAccent(data.accent);
        document.getElementById('colorPicker').value = data.accent;
    }
}

function changeDifficulty(val) {
    if(confirm("Changing difficulty requires a world reset. Continue?")) {
        mineDensity = parseFloat(val);
        revealed.clear(); flagged.clear(); detonated.clear();
        worldSeed = Math.floor(Math.random() * 999999);
        camera = {x:0, y:0};
        saveGame();
    } else {
        document.getElementById('diffSelect').value = mineDensity;
    }
}

const getSeed = (x, y) => {
    let n = Math.sin((x + worldSeed) * 12.9898 + (y + worldSeed) * 78.233) * 43758.5453;
    return n - Math.floor(n);
};
const hasMine = (x, y) => getSeed(x, y) < mineDensity;
const getCount = (x, y) => {
    let c = 0;
    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
        if(i===0 && j===0) continue;
        if(hasMine(x+i, y+j)) c++;
    }
    return c;
};

function reveal(x, y) {
    if(revealed.size === 0) { while(hasMine(x,y) || getCount(x,y) > 0) worldSeed++; }
    const k = `${x},${y}`;
    if(revealed.has(k) || flagged.has(k)) return;
    revealed.add(k);
    if(hasMine(x,y)) { detonated.add(k); }
    else if(getCount(x,y) === 0) {
        for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) reveal(x+i, y+j);
    }
    saveGame();
}

function toggleFlag(x, y) {
    let k = `${x},${y}`;
    if(!revealed.has(k)) {
        flagged.has(k) ? flagged.delete(k) : flagged.add(k);
        saveGame();
    }
}

function smartChord(x, y) {
    const k = `${x},${y}`;
    if (!revealed.has(k)) return;
    let mines = getCount(x, y), currentFlags = 0, neighbors = [];
    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
        if(i===0 && j===0) continue;
        let nk = `${x+i},${y+j}`;
        if(flagged.has(nk) || detonated.has(nk)) currentFlags++;
        if(!revealed.has(nk) && !flagged.has(nk)) neighbors.push({x: x+i, y: y+j});
    }
    if(currentFlags === mines) {
        neighbors.forEach(n => reveal(n.x, n.y));
        saveGame();
    }
}

function toggleMenu() { document.getElementById('warpModal').classList.remove('active'); document.getElementById('side-menu').classList.toggle('active'); }
function toggleWarp() { document.getElementById('side-menu').classList.remove('active'); const w = document.getElementById('warpModal'); const active = w.classList.toggle('active'); if(active) document.getElementById('warpIn').focus(); }
function updateAccent(val) { document.documentElement.style.setProperty('--accent', val); saveGame(); }
function toggleTheme() { document.body.classList.toggle('light-mode'); }
function doWarp() { let p = document.getElementById('warpIn').value.split(',').map(Number); if(!isNaN(p[0])) { camera.x = p[0] * TILE_SIZE; camera.y = (p[1]||0) * TILE_SIZE; } document.getElementById('warpModal').classList.remove('active'); saveGame(); }
function confirmReset() { if(confirm("Regenerate World? All progress will be lost.")) { localStorage.removeItem('inf_minesweeper_save'); location.reload(); } }

function render() {
    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    const moveSpeed = 12 / zoom;
    if(keys['KeyW'] || keys['ArrowUp']) camera.y -= moveSpeed;
    if(keys['KeyS'] || keys['ArrowDown']) camera.y += moveSpeed;
    if(keys['KeyA'] || keys['ArrowLeft']) camera.x -= moveSpeed;
    if(keys['KeyD'] || keys['ArrowRight']) camera.x += moveSpeed;

    zoom += (targetZoom - zoom) * 0.15;
    const curSize = Math.round(TILE_SIZE * zoom);
    
    // Level of Detail (LOD) check
    const isUltraZoomed = curSize < 8;

    const hw = canvas.width/2, hh = canvas.height/2;
    const startX = Math.floor((camera.x - hw/zoom) / TILE_SIZE);
    const startY = Math.floor((camera.y - hh/zoom) / TILE_SIZE);
    const endX = startX + Math.ceil(canvas.width/curSize) + 2;
    const endY = startY + Math.ceil(canvas.height/curSize) + 2;

    ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg');
    ctx.fillRect(0,0, canvas.width, canvas.height);

    for(let x=startX; x<endX; x++) {
        for(let y=startY; y<endY; y++) {
            const sx = Math.round((x * TILE_SIZE - camera.x) * zoom + hw);
            const sy = Math.round((y * TILE_SIZE - camera.y) * zoom + hh);
            const k = `${x},${y}`;
            let isDepressed = chordTarget && Math.abs(x - chordTarget.x) <= 1 && Math.abs(y - chordTarget.y) <= 1;

            if(!revealed.has(k)) {
                // Draw Unrevealed
                ctx.fillStyle = flagged.has(k) ? "#ff3333" : "var(--panel)";
                ctx.fillRect(sx, sy, curSize, curSize);
                
                if (!isUltraZoomed) {
                    if(isDepressed && !flagged.has(k)) {
                        ctx.strokeStyle = "var(--inset)";
                        ctx.strokeRect(sx, sy, curSize, curSize);
                    } else {
                        ctx.fillStyle = "var(--tile-highlight)";
                        ctx.fillRect(sx, sy, curSize, 1); ctx.fillRect(sx, sy, 1, curSize);
                        ctx.fillStyle = "var(--tile-shadow)";
                        ctx.fillRect(sx+curSize-1, sy, 1, curSize); ctx.fillRect(sx, sy+curSize-1, curSize, 1);
                    }
                }
            } else {
                // Draw Revealed
                ctx.fillStyle = detonated.has(k) ? "rgba(255,0,0,0.6)" : "var(--bg)";
                ctx.fillRect(sx, sy, curSize, curSize);
                
                if(!isUltraZoomed) {
                    ctx.strokeStyle = "var(--inset)";
                    ctx.strokeRect(sx, sy, curSize, curSize);
                    
                    if(hasMine(x,y)) {
                        ctx.fillStyle = "var(--accent)";
                        ctx.beginPath(); ctx.arc(sx+curSize/2, sy+curSize/2, curSize/4, 0, 7); ctx.fill();
                    } else {
                        let n = getCount(x,y);
                        if(n>0 && curSize > 15) {
                            ctx.fillStyle = ["","blue","#2ecc71","#e74c3c","#3498db","brown","cyan","black","gray"][n];
                            ctx.font = `bold ${20*zoom}px Arial`; ctx.textAlign="center";
                            ctx.fillText(n, sx + curSize/2, sy + curSize/1.3);
                        }
                    }
                }
            }
        }
    }

    document.getElementById('det-count').innerText = detonated.size;
    document.getElementById('flg-count').innerText = flagged.size;
    document.getElementById('menu-revealed').innerText = revealed.size;
    
    let currentLap = isTabActive ? (Date.now() - startTime) : 0;
    document.getElementById('menu-time').innerText = formatTime(totalPlayedTime + currentLap);
    
    const camX = Math.round(camera.x/TILE_SIZE), camY = Math.round(camera.y/TILE_SIZE);
    document.getElementById('cam-coords').innerText = `${camX}, ${camY}`;
    
    mCtx.fillStyle = "#000"; mCtx.fillRect(0,0,100,100);
    revealed.forEach(rk => {
        let [kx, ky] = rk.split(',').map(Number);
        mCtx.fillStyle = detonated.has(rk) ? "red" : "#fff";
        mCtx.fillRect(50 + (kx-camX), 50 + (ky-camY), 2, 2);
    });
    mCtx.strokeStyle = "var(--accent)"; mCtx.strokeRect(48, 48, 4, 4);
    requestAnimationFrame(render);
}

function isOverUI(e) { 
    const el = e.target || (e.touches ? e.touches[0].target : e.target);
    return el.closest('#hud, #top-right, #side-menu, .modal'); 
}

canvas.addEventListener('wheel', e => {
    if(isOverUI(e)) return;
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.88 : 1.12;
    // Massive zoom-out range: 0.01 to 4.0
    targetZoom = Math.max(0.01, Math.min(targetZoom * delta, 4.0));
}, {passive:false});

canvas.addEventListener('touchstart', e => {
    if(isOverUI(e)) return;
    const t = e.touches[0];
    lastMouse = {x: t.clientX, y: t.clientY};
    isDragging = true; dragMoved = false;
    const wx = (t.clientX - canvas.width/2)/zoom + camera.x;
    const wy = (t.clientY - canvas.height/2)/zoom + camera.y;
    const tx = Math.floor(wx/TILE_SIZE), ty = Math.floor(wy/TILE_SIZE);
    if(revealed.has(`${tx},${ty}`)) chordTarget = {x: tx, y: ty};
    touchTimer = setTimeout(() => {
        if(!dragMoved) { toggleFlag(tx, ty); isDragging = false; chordTarget = null; if (window.navigator.vibrate) window.navigator.vibrate(50); }
    }, 500);
}, {passive:true});

canvas.addEventListener('touchmove', e => {
    if(!isDragging) return;
    const t = e.touches[0];
    let dx = t.clientX - lastMouse.x;
    let dy = t.clientY - lastMouse.y;
    if(Math.abs(dx) > 5 || Math.abs(dy) > 5) { dragMoved = true; clearTimeout(touchTimer); chordTarget = null; camera.x -= dx / zoom; camera.y -= dy / zoom; }
    lastMouse = {x: t.clientX, y: t.clientY};
}, {passive:true});

canvas.addEventListener('touchend', e => {
    clearTimeout(touchTimer);
    if(isDragging && !dragMoved) {
        const t = e.changedTouches[0];
        const wx = (t.clientX - canvas.width/2)/zoom + camera.x;
        const wy = (t.clientY - canvas.height/2)/zoom + camera.y;
        const tx = Math.floor(wx/TILE_SIZE), ty = Math.floor(wy/TILE_SIZE);
        if(chordTarget) smartChord(chordTarget.x, chordTarget.y); else reveal(tx, ty);
    }
    isDragging = false; dragMoved = false; chordTarget = null;
}, {passive:true});

window.addEventListener('mousedown', e => {
    if(isOverUI(e)) return;
    lastMouse = {x: e.clientX, y: e.clientY};
    isDragging = true; dragMoved = false;
    const wx = (e.clientX - canvas.width/2)/zoom + camera.x;
    const wy = (e.clientY - canvas.height/2)/zoom + camera.y;
    const tx = Math.floor(wx/TILE_SIZE), ty = Math.floor(wy/TILE_SIZE);
    if(e.button === 2) { toggleFlag(tx, ty); }
    else if(e.button === 0 && revealed.has(`${tx},${ty}`)) { chordTarget = {x: tx, y: ty}; }
});
window.addEventListener('mousemove', e => { if(isDragging) { let dx = e.clientX - lastMouse.x; let dy = e.clientY - lastMouse.y; if(Math.abs(dx) > 3 || Math.abs(dy) > 3) { dragMoved = true; camera.x -= dx / zoom; camera.y -= dy / zoom; } } lastMouse = {x: e.clientX, y: e.clientY}; });
window.addEventListener('mouseup', e => { if(isDragging && !dragMoved && !isOverUI(e) && e.button === 0) { const wx = (e.clientX - canvas.width/2)/zoom + camera.x; const wy = (e.clientY - canvas.height/2)/zoom + camera.y; const tx = Math.floor(wx/TILE_SIZE), ty = Math.floor(wy/TILE_SIZE); if(chordTarget) smartChord(chordTarget.x, chordTarget.y); else reveal(tx, ty); } isDragging = false; chordTarget = null; });
window.addEventListener('keydown', e => { keys[e.code] = true; if(e.code === 'Enter' && document.getElementById('warpModal').classList.contains('active')) doWarp(); });
window.addEventListener('keyup', e => keys[e.code] = false);
window.oncontextmenu = e => e.preventDefault();
loadGame();
render();
</script>
</body>
</html>
